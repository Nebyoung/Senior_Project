#Senior_Project
N-Gram Machine Code Statistical Analysis and Application
Benjamin Young with Mentor George Amariucai
        	Currently, there is little to no information readily available regarding the results of decryption of encrypted stack elements using spurious keys. The attempt at using an incorrect key to decrypt stack elements is readily dismissed, being considered nothing short of a mistake, or a single attempt of many at discovering the correct key. Incorrectly decrypting stack elements typically results in seemingly random machine code instructions that tend to bring the program to a crashing halt. What I propose, with thanks to Associate Professor Amariucai for the idea and inspiration, is to create a tool capable of providing a statistical analysis of the likelihood of benefiting from spurious decryption of stack elements.
This tool will implement an N-gram analysis algorithm to discover the most frequent 1-grams, 2-grams, 3-grams, etc…, of a given application’s machine code, with the intent being to discover the likelihood of running into program control disrupting instructions at a given number of instructions from the decryption point. In other words, how likely is an attacker, after spuriously decrypting a stack element, to experience control disruption after a single instruction? Two instructions? Three? Of course, after an infinite number of instructions the total percent chance of control being disrupted will approach 100%. As such, it would be useful to provide users with a graphical representation of the percent chance of disruption at each count of instructions, until the total asymptotically approaches 0% increase per additional instruction. This graph could grant attackers the knowledge of, on average, how many instructions they could get executed before their control is disrupted.
Naturally, to correctly compute this data, I will need to find every instruction set I can that will lead to program control disruption. Such instruction sets not only include instructions to exit or return, but also those that may or may not disrupt control based on the following instructions acting as parameters to instructions such as jump or move. This will likely prove to be the more difficult task, but I am certain I can gather this information, at least partially, by analyzing already available lists of all possible machine code instructions. Such lists would only fail to account for disruption from parameter reliant instructions. Upon completion, this tool will be made publically available for any who might benefit from its use.
To summarize, my short term goals for this project are the design and implementation of the analysis algorithm, compiling the list of possible disrupting instructions into a database linked to the algorithm implementation, and to create a publically accessible and usable webpage to host the tool such that other researches can easily put it to use in their own work.
The more ambitious and long term goal is to apply the data gathered from this tool toward deobfuscation of code. Currently, deobfuscation of well obscured code requires quite a bit of manual work, visually sorting through the code to understand its workings, or using reverse engineering tools such as IDA. However, even dedicated tools like IDA have shortcomings; quite a few techniques have been discovered that reduce IDAs capability to deobsfucate code, such as code chunking or extraneous NOP instruction sets. This tool, once developed, could potentially be used toward deobfuscation similarly to how letter frequency analysis can be used toward decrypting substitution encrypted cipher-text.
